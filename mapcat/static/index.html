<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mapcat Map</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
    <style>
        #map { width: 100vw; height: 100vh; margin: 0; }
    </style>
</head>
<body>
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
    // Initialize map
    var map = L.map('map').setView([52.527913, 13.416302], 15);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: 'Â© OpenStreetMap'
    }).addTo(map);

    // Store features by ID
    var features = {};

    // WebSocket connection
    var ws_port = (location.port ? (parseInt(location.port) + 1) : 8081);
    var ws_url = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.hostname + ':' + ws_port;
    var ws = new WebSocket(ws_url);

    ws.onopen = function() {
        console.log('WebSocket connected');
    };
    
    ws.onclose = function() {
        console.log('WebSocket disconnected');
    };
    
    ws.onerror = function(e) {
        console.error('WebSocket error', e);
    };

    ws.onmessage = function(event) {
        try {
            var msg = JSON.parse(event.data);
            console.log('Received:', msg);
            handleMessage(msg);
        } catch (e) {
            console.error('Invalid message', event.data, e);
        }
    };

    function handleMessage(msg) {
        if (!msg || !msg.action) {
            console.warn('Message missing action', msg);
            return;
        }

        if (msg.action === 'add') {
            addFeature(msg);
        } else if (msg.action === 'remove') {
            removeFeature(msg.id);
        } else if (msg.action === 'clear') {
            clearAllFeatures();
        } else {
            console.warn('Unknown action', msg.action);
        }
    }

    function addFeature(msg) {
        var layer;
        var params = msg.params || {};
        var color = params.color || '#007cff';
        var label = params.label;

        if (msg.type === 'point') {
            layer = L.circleMarker(msg.coords, {
                radius: 8,
                color: color,
                fillColor: color,
                fillOpacity: 0.7,
                weight: 2
            }).addTo(map);
            
            if (label) {
                layer.bindTooltip(label, { permanent: false, direction: 'top' });
            }
        } else if (msg.type === 'polyline') {
            var width = params.width ? parseInt(params.width) : 3;
            var opacity = params.opacity ? parseFloat(params.opacity) : 0.7;
            
            // Create a layer group to hold both the line and point markers
            var layerGroup = L.layerGroup();
            
            // Add the polyline
            var line = L.polyline(msg.coords, {
                color: color,
                weight: width,
                opacity: opacity
            });
            layerGroup.addLayer(line);
            
            // Add circle markers at each point
            var markerRadius = width * 1.5;
            msg.coords.forEach(function(coord) {
                var marker = L.circleMarker(coord, {
                    radius: markerRadius,
                    color: color,
                    fillColor: color,
                    fillOpacity: 1.0,
                    weight: 2
                });
                layerGroup.addLayer(marker);
            });
            
            layer = layerGroup;
            layer.addTo(map);
            
            if (label) {
                line.bindTooltip(label);
            }
        } else if (msg.type === 'polygon') {
            var opacity = params.opacity ? parseFloat(params.opacity) : 0.3;
            
            layer = L.polygon(msg.coords, {
                color: color,
                fillColor: color,
                fillOpacity: opacity,
                weight: 2
            }).addTo(map);
            
            if (label) {
                layer.bindTooltip(label);
            }
        } else {
            console.warn('Unknown feature type', msg.type);
            return;
        }

        features[msg.id] = layer;
        
        // Auto-fit bounds to show all features
        if (Object.keys(features).length > 0) {
            var group = L.featureGroup(Object.values(features));
            map.fitBounds(group.getBounds(), { padding: [20, 20] });
        }
    }

    function removeFeature(id) {
        var layer = features[id];
        if (layer) {
            map.removeLayer(layer);
            delete features[id];
            console.log('Removed feature', id);
        } else {
            console.warn('Feature not found', id);
        }
    }

    function clearAllFeatures() {
        Object.keys(features).forEach(function(id) {
            map.removeLayer(features[id]);
        });
        features = {};
        console.log('Cleared all features');
    }
    </script>
</body>
</html>
