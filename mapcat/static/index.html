<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mapcat</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
    <style>
        #map { width: 100vw; height: 100vh; margin: 0; }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #controls button {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 8px 12px;
            background: #007cff;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }
        #controls button:hover {
            background: #0056b3;
        }
        #controls button.active {
            background: #28a745;
        }
        #controls button.clear {
            background: #dc3545;
            margin-top: 10px;
        }
        #controls button.clear:hover {
            background: #c82333;
        }
        .leaflet-interactive:hover {
            filter: drop-shadow(0 0 8px currentColor);
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="autofocusBtn" class="active">Auto-focus: ON</button>
        <button id="followPositionBtn">Follow Position: OFF</button>
        <button id="clearBtn" class="clear">Clear</button>
    </div>
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
    // Initialize map
    var map = L.map('map').setView([52.527913, 13.416302], 15);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: 'Â© OpenStreetMap'
    }).addTo(map);

    // Store features by ID
    var features = {};
    
    // Current position state
    var currentPositionMarker = null;
    var previousPosition = null;
    var followPosition = false;
    
    // Auto-focus state
    var autofocus = true;

    // Control panel
    var autofocusBtn = document.getElementById('autofocusBtn');
    autofocusBtn.addEventListener('click', function() {
        autofocus = !autofocus;
        if (autofocus) {
            autofocusBtn.textContent = 'Auto-focus: ON';
            autofocusBtn.className = 'active';
        } else {
            autofocusBtn.textContent = 'Auto-focus: OFF';
            autofocusBtn.className = '';
        }
    });
    
    var followPositionBtn = document.getElementById('followPositionBtn');
    followPositionBtn.addEventListener('click', function() {
        followPosition = !followPosition;
        if (followPosition) {
            followPositionBtn.textContent = 'Follow Position: ON';
            followPositionBtn.className = 'active';
        } else {
            followPositionBtn.textContent = 'Follow Position: OFF';
            followPositionBtn.className = '';
        }
    });
    
    var clearBtn = document.getElementById('clearBtn');
    clearBtn.addEventListener('click', function() {
        clearAllFeatures();
        // Also remove current position marker
        if (currentPositionMarker) {
            map.removeLayer(currentPositionMarker);
            currentPositionMarker = null;
            previousPosition = null;
        }
    });
    
    // Disable auto-focus and follow position when user drags the map
    map.on('dragstart', function() {
        if (autofocus) {
            autofocus = false;
            autofocusBtn.textContent = 'Auto-focus: OFF';
            autofocusBtn.className = '';
        }
        if (followPosition) {
            followPosition = false;
            followPositionBtn.textContent = 'Follow Position: OFF';
            followPositionBtn.className = '';
        }
    });

    // WebSocket connection
    var ws_port = (location.port ? (parseInt(location.port) + 1) : 8081);
    var ws_url = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.hostname + ':' + ws_port;
    var ws = new WebSocket(ws_url);

    ws.onopen = function() {
        console.log('WebSocket connected');
    };
    
    ws.onclose = function() {
        console.log('WebSocket disconnected');
    };
    
    ws.onerror = function(e) {
        console.error('WebSocket error', e);
    };

    ws.onmessage = function(event) {
        try {
            var msg = JSON.parse(event.data);
            console.log('Received:', msg);
            handleMessage(msg);
        } catch (e) {
            console.error('Invalid message', event.data, e);
        }
    };

    function handleMessage(msg) {
        if (!msg || !msg.action) {
            console.warn('Message missing action', msg);
            return;
        }

        if (msg.action === 'add') {
            addFeature(msg);
        } else if (msg.action === 'remove') {
            removeFeature(msg.id);
        } else if (msg.action === 'remove-by-tag') {
            removeFeaturesByTag(msg.ids);
        } else if (msg.action === 'clear') {
            clearAllFeatures();
        } else if (msg.action === 'update-current-position') {
            updateCurrentPosition(msg.coords);
        } else {
            console.warn('Unknown action', msg.action);
        }
    }

    function addFeature(msg) {
        var layer;
        var params = msg.params || {};
        var color = params.color;
        var label = params.label;
        var tag = params.tag;
        var opacity = params.opacity;

        if (msg.type === 'point') {
            var radius = params.radius;
            var border = params.border;
            
            // Validate required parameters
            if (color === undefined || opacity === undefined || radius === undefined || border === undefined) {
                console.error('Missing required parameters for point:', msg);
                console.error('Required: color, opacity, radius, border');
                ws.send(JSON.stringify({
                    type: 'error',
                    message: 'Missing required parameters for point: color, opacity, radius, border',
                    feature: msg
                }));
                return;
            }
            
            layer = L.circleMarker(msg.coords, {
                radius: radius,
                color: color,
                fillColor: color,
                fillOpacity: opacity,
                opacity: opacity,
                weight: border
            }).addTo(map);
            
            // Add hover effect for points
            setupHoverEffect(layer, {
                originalOpacity: opacity,
                originalWeight: border,
                originalColor: color
            });
            
            // Build tooltip text (label only, no tag)
            if (label) {
                layer.bindTooltip(label, { permanent: false, direction: 'top', offset: [0, -15] });
            }
        } else if (msg.type === 'polyline') {
            var width = params.width;
            var markerRadius = params.markers;
            var markerBorder = params.markerBorder;
            
            // Validate required parameters
            if (color === undefined || opacity === undefined || width === undefined || 
                markerRadius === undefined || markerBorder === undefined) {
                console.error('Missing required parameters for polyline:', msg);
                console.error('Required: color, opacity, width, markers, markerBorder');
                ws.send(JSON.stringify({
                    type: 'error',
                    message: 'Missing required parameters for polyline: color, opacity, width, markers, markerBorder',
                    feature: msg
                }));
                return;
            }
            
            // Create a layer group to hold both the line and point markers
            var layerGroup = L.layerGroup();
            var markers = [];
            
            // Add the polyline
            var line = L.polyline(msg.coords, {
                color: color,
                weight: width,
                opacity: opacity
            });
            layerGroup.addLayer(line);
            
            // Add circle markers at each point (if markers > 0)
            if (markerRadius > 0) {
                msg.coords.forEach(function(coord) {
                    var marker = L.circleMarker(coord, {
                        radius: markerRadius,
                        color: color,
                        fillColor: color,
                        fillOpacity: opacity,
                        opacity: opacity,
                        weight: markerBorder
                    });
                    layerGroup.addLayer(marker);
                    markers.push(marker);
                });
            }
            
            // Add synchronized hover effect for polyline and its markers
            setupPolylineHoverEffect(line, markers, {
                originalOpacity: opacity,
                originalWeight: width,
                originalColor: color,
                originalMarkerWeight: markerBorder
            });
            
            layer = layerGroup;
            layer.addTo(map);
            
            // Build tooltip text (label only, no tag)
            if (label) {
                setupSmartTooltip(line, label, 'polyline', msg.coords);
            }
        } else if (msg.type === 'polygon') {
            var border = params.border;
            
            // Validate required parameters
            if (color === undefined || opacity === undefined || border === undefined) {
                console.error('Missing required parameters for polygon:', msg);
                console.error('Required: color, opacity, border');
                ws.send(JSON.stringify({
                    type: 'error',
                    message: 'Missing required parameters for polygon: color, opacity, border',
                    feature: msg
                }));
                return;
            }
            
            layer = L.polygon(msg.coords, {
                color: color,
                fillColor: color,
                fillOpacity: opacity,
                opacity: opacity,
                weight: border
            }).addTo(map);
            
            // Add hover effect for polygons
            setupHoverEffect(layer, {
                originalOpacity: opacity,
                originalWeight: border,
                originalColor: color
            });
            
            // Build tooltip text (label only, no tag)
            if (label) {
                setupSmartTooltip(layer, label, 'polygon', msg.coords);
            }
        } else {
            console.warn('Unknown feature type', msg.type);
            return;
        }

        features[msg.id] = layer;
        
        // Auto-fit bounds to show all features (if autofocus enabled)
        if (autofocus && Object.keys(features).length > 0) {
            var bounds = null;
            Object.values(features).forEach(function(feature) {
                var featureBounds = null;
                if (feature.getBounds) {
                    featureBounds = feature.getBounds();
                } else if (feature.getLatLng) {
                    // Single marker
                    var latlng = feature.getLatLng();
                    featureBounds = L.latLngBounds([latlng, latlng]);
                } else if (feature instanceof L.LayerGroup) {
                    // For LayerGroups (like polylines with markers), calculate bounds from all layers
                    var groupBounds = null;
                    feature.eachLayer(function(subLayer) {
                        if (subLayer.getBounds) {
                            var subBounds = subLayer.getBounds();
                            groupBounds = groupBounds ? groupBounds.extend(subBounds) : subBounds;
                        } else if (subLayer.getLatLng) {
                            var latlng = subLayer.getLatLng();
                            groupBounds = groupBounds ? groupBounds.extend(latlng) : L.latLngBounds([latlng, latlng]);
                        }
                    });
                    featureBounds = groupBounds;
                }
                
                if (featureBounds) {
                    bounds = bounds ? bounds.extend(featureBounds) : featureBounds;
                }
            });
            
            if (bounds) {
                map.fitBounds(bounds, { padding: [20, 20] });
            }
        }
    }

    function removeFeature(id) {
        var layer = features[id];
        if (layer) {
            map.removeLayer(layer);
            delete features[id];
            console.log('Removed feature', id);
        } else {
            console.warn('Feature not found', id);
        }
    }
    
    function removeFeaturesByTag(ids) {
        ids.forEach(function(id) {
            var layer = features[id];
            if (layer) {
                map.removeLayer(layer);
                delete features[id];
            }
        });
        console.log('Removed', ids.length, 'features by tag');
    }

    function clearAllFeatures() {
        Object.keys(features).forEach(function(id) {
            map.removeLayer(features[id]);
        });
        features = {};
        console.log('Cleared all features');
    }
    
    function setupHoverEffect(layer, originalStyle) {
        layer.on('mouseover', function(e) {
            // Add yellow border without magnifying
            var style = {
                color: '#FFD700',
                weight: (originalStyle.originalWeight || 2) + 3
            };
            
            // For points (circle markers), also change fill color to yellow
            if (originalStyle.originalColor !== undefined) {
                style.fillColor = '#FFD700';
            }
            
            layer.setStyle(style);
        });
        
        layer.on('mouseout', function(e) {
            // Restore original style
            var style = {
                opacity: originalStyle.originalOpacity,
                fillOpacity: originalStyle.originalOpacity
            };
            
            if (originalStyle.originalWeight !== undefined) {
                style.weight = originalStyle.originalWeight;
            }
            
            if (originalStyle.originalColor !== undefined) {
                style.color = originalStyle.originalColor;
                style.fillColor = originalStyle.originalColor;
            }
            
            layer.setStyle(style);
        });
    }
    
    function setupPolylineHoverEffect(line, markers, originalStyle) {
        var applyHover = function() {
            line.setStyle({
                color: '#FFD700',
                weight: (originalStyle.originalWeight || 2) + 3
            });
            
            markers.forEach(function(marker) {
                marker.setStyle({
                    color: '#FFD700',
                    fillColor: '#FFD700',
                    weight: (originalStyle.originalMarkerWeight || 2) + 3
                });
            });
        };
        
        var removeHover = function() {
            line.setStyle({
                opacity: originalStyle.originalOpacity,
                color: originalStyle.originalColor,
                weight: originalStyle.originalWeight
            });
            
            markers.forEach(function(marker) {
                marker.setStyle({
                    opacity: originalStyle.originalOpacity,
                    fillOpacity: originalStyle.originalOpacity,
                    color: originalStyle.originalColor,
                    fillColor: originalStyle.originalColor,
                    weight: originalStyle.originalMarkerWeight
                });
            });
        };
        
        // Apply hover to both line and markers
        line.on('mouseover', applyHover);
        line.on('mouseout', removeHover);
        
        markers.forEach(function(marker) {
            marker.on('mouseover', applyHover);
            marker.on('mouseout', removeHover);
        });
    }
    
    function setupSmartTooltip(layer, label, featureType, coords) {
        if (featureType === 'polyline') {
            // For polylines, calculate perpendicular direction dynamically
            layer.on('mousemove', function(e) {
                var mouseLatLng = e.latlng;
                var closestSegment = findClosestSegment(coords, mouseLatLng);
                var direction = getPerpendicularDirection(closestSegment);
                
                // Update tooltip with calculated direction
                layer.unbindTooltip();
                layer.bindTooltip(label, { 
                    direction: direction,
                    offset: getOffsetForDirection(direction, 10)
                });
                layer.openTooltip(mouseLatLng);
            });
        } else if (featureType === 'polygon') {
            // For polygons, position tooltip away from centroid
            layer.on('mousemove', function(e) {
                var mouseLatLng = e.latlng;
                var centroid = calculateCentroid(coords);
                var direction = getDirectionAwayFromPoint(centroid, mouseLatLng);
                
                // Update tooltip with calculated direction
                layer.unbindTooltip();
                layer.bindTooltip(label, { 
                    direction: direction,
                    offset: getOffsetForDirection(direction, 10)
                });
                layer.openTooltip(mouseLatLng);
            });
        }
    }
    
    function findClosestSegment(coords, point) {
        var minDist = Infinity;
        var closestSegment = null;
        
        for (var i = 0; i < coords.length - 1; i++) {
            var p1 = coords[i];
            var p2 = coords[i + 1];
            var dist = pointToSegmentDistance(point, p1, p2);
            
            if (dist < minDist) {
                minDist = dist;
                closestSegment = { p1: p1, p2: p2 };
            }
        }
        
        return closestSegment;
    }
    
    function pointToSegmentDistance(point, segStart, segEnd) {
        var lat = point.lat;
        var lng = point.lng;
        var lat1 = segStart[0];
        var lng1 = segStart[1];
        var lat2 = segEnd[0];
        var lng2 = segEnd[1];
        
        var A = lat - lat1;
        var B = lng - lng1;
        var C = lat2 - lat1;
        var D = lng2 - lng1;
        
        var dot = A * C + B * D;
        var lenSq = C * C + D * D;
        var param = lenSq !== 0 ? dot / lenSq : -1;
        
        var xx, yy;
        
        if (param < 0) {
            xx = lat1;
            yy = lng1;
        } else if (param > 1) {
            xx = lat2;
            yy = lng2;
        } else {
            xx = lat1 + param * C;
            yy = lng1 + param * D;
        }
        
        var dx = lat - xx;
        var dy = lng - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    function getPerpendicularDirection(segment) {
        var lat1 = segment.p1[0];
        var lng1 = segment.p1[1];
        var lat2 = segment.p2[0];
        var lng2 = segment.p2[1];
        
        var dLat = lat2 - lat1;
        var dLng = lng2 - lng1;
        
        // Calculate angle of the line segment
        var angle = Math.atan2(dLat, dLng) * 180 / Math.PI;
        
        // Normalize to 0-360
        if (angle < 0) angle += 360;
        
        // Determine perpendicular direction (prefer upward/rightward)
        if (angle >= 45 && angle < 135) {
            return 'right'; // Line goes up, tooltip to the right
        } else if (angle >= 135 && angle < 225) {
            return 'top'; // Line goes left, tooltip above
        } else if (angle >= 225 && angle < 315) {
            return 'left'; // Line goes down, tooltip to the left
        } else {
            return 'top'; // Line goes right, tooltip above (not below)
        }
    }
    
    function calculateCentroid(coords) {
        var latSum = 0, lngSum = 0;
        coords.forEach(function(coord) {
            latSum += coord[0];
            lngSum += coord[1];
        });
        return {
            lat: latSum / coords.length,
            lng: lngSum / coords.length
        };
    }
    
    function getDirectionAwayFromPoint(fromPoint, toPoint) {
        var dLat = toPoint.lat - fromPoint.lat;
        var dLng = toPoint.lng - fromPoint.lng;
        
        // Determine primary direction
        if (Math.abs(dLat) > Math.abs(dLng)) {
            return dLat > 0 ? 'top' : 'bottom';
        } else {
            return dLng > 0 ? 'right' : 'left';
        }
    }
    
    function getOffsetForDirection(direction, distance) {
        switch(direction) {
            case 'top': return [0, -distance];
            case 'bottom': return [0, distance];
            case 'left': return [-distance, 0];
            case 'right': return [distance, 0];
            default: return [0, -distance];
        }
    }
    
    function updateCurrentPosition(coords) {
        // Remove old marker if exists
        if (currentPositionMarker) {
            map.removeLayer(currentPositionMarker);
        }
        
        // Calculate heading (bearing) from previous position
        var rotation = 0;
        if (previousPosition) {
            var lat1 = previousPosition[0] * Math.PI / 180;
            var lat2 = coords[0] * Math.PI / 180;
            var dLon = (coords[1] - previousPosition[1]) * Math.PI / 180;
            
            var y = Math.sin(dLon) * Math.cos(lat2);
            var x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
            rotation = Math.atan2(y, x) * 180 / Math.PI;
        }
        
        // Create chevron icon (pointing upward, will be rotated)
        var chevronIcon = L.divIcon({
            className: 'current-position-icon',
            html: '<div style="transform: rotate(' + rotation + 'deg); width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 20px solid #4285F4; margin-left: -10px; margin-top: -10px;"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
        
        // Add new marker
        currentPositionMarker = L.marker(coords, { icon: chevronIcon }).addTo(map);
        
        // Follow position if enabled
        if (followPosition) {
            map.setView(coords, map.getZoom());
        }
        
        // Store for next heading calculation
        previousPosition = coords;
    }
    </script>
</body>
</html>
