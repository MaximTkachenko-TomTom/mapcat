<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mapcat Map</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
    <style>
        #map { width: 100vw; height: 100vh; margin: 0; }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #controls button {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 8px 12px;
            background: #007cff;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }
        #controls button:hover {
            background: #0056b3;
        }
        #controls button.active {
            background: #28a745;
        }
        #controls button.clear {
            background: #dc3545;
            margin-top: 10px;
        }
        #controls button.clear:hover {
            background: #c82333;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="autofocusBtn" class="active">Auto-focus: ON</button>
        <button id="followPositionBtn">Follow Position: OFF</button>
        <button id="clearBtn" class="clear">Clear</button>
    </div>
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
    // Initialize map
    var map = L.map('map').setView([52.527913, 13.416302], 15);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: 'Â© OpenStreetMap'
    }).addTo(map);

    // Store features by ID
    var features = {};
    
    // Current position state
    var currentPositionMarker = null;
    var previousPosition = null;
    var followPosition = false;
    
    // Auto-focus state
    var autofocus = true;

    // Control panel
    var autofocusBtn = document.getElementById('autofocusBtn');
    autofocusBtn.addEventListener('click', function() {
        autofocus = !autofocus;
        if (autofocus) {
            autofocusBtn.textContent = 'Auto-focus: ON';
            autofocusBtn.className = 'active';
        } else {
            autofocusBtn.textContent = 'Auto-focus: OFF';
            autofocusBtn.className = '';
        }
    });
    
    var followPositionBtn = document.getElementById('followPositionBtn');
    followPositionBtn.addEventListener('click', function() {
        followPosition = !followPosition;
        if (followPosition) {
            followPositionBtn.textContent = 'Follow Position: ON';
            followPositionBtn.className = 'active';
        } else {
            followPositionBtn.textContent = 'Follow Position: OFF';
            followPositionBtn.className = '';
        }
    });
    
    var clearBtn = document.getElementById('clearBtn');
    clearBtn.addEventListener('click', function() {
        clearAllFeatures();
        // Also remove current position marker
        if (currentPositionMarker) {
            map.removeLayer(currentPositionMarker);
            currentPositionMarker = null;
            previousPosition = null;
        }
    });

    // WebSocket connection
    var ws_port = (location.port ? (parseInt(location.port) + 1) : 8081);
    var ws_url = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.hostname + ':' + ws_port;
    var ws = new WebSocket(ws_url);

    ws.onopen = function() {
        console.log('WebSocket connected');
    };
    
    ws.onclose = function() {
        console.log('WebSocket disconnected');
    };
    
    ws.onerror = function(e) {
        console.error('WebSocket error', e);
    };

    ws.onmessage = function(event) {
        try {
            var msg = JSON.parse(event.data);
            console.log('Received:', msg);
            handleMessage(msg);
        } catch (e) {
            console.error('Invalid message', event.data, e);
        }
    };

    function handleMessage(msg) {
        if (!msg || !msg.action) {
            console.warn('Message missing action', msg);
            return;
        }

        if (msg.action === 'add') {
            addFeature(msg);
        } else if (msg.action === 'remove') {
            removeFeature(msg.id);
        } else if (msg.action === 'remove-by-tag') {
            removeFeaturesByTag(msg.ids);
        } else if (msg.action === 'clear') {
            clearAllFeatures();
        } else if (msg.action === 'update-current-position') {
            updateCurrentPosition(msg.coords);
        } else {
            console.warn('Unknown action', msg.action);
        }
    }

    function addFeature(msg) {
        var layer;
        var params = msg.params || {};
        var color = params.color || '#007cff';
        var label = params.label;
        var tag = params.tag;

        if (msg.type === 'point') {
            layer = L.circleMarker(msg.coords, {
                radius: 8,
                color: color,
                fillColor: color,
                fillOpacity: 0.7,
                weight: 2
            }).addTo(map);
            
            // Build tooltip text
            var tooltipText = '';
            if (label) {
                tooltipText = label;
            }
            if (tag) {
                tooltipText += (tooltipText ? ' [' : '[') + tag + ']';
            }
            if (tooltipText) {
                layer.bindTooltip(tooltipText, { permanent: false, direction: 'top' });
            }
        } else if (msg.type === 'polyline') {
            var width = params.width ? parseInt(params.width) : 3;
            var opacity = params.opacity ? parseFloat(params.opacity) : 1.0;
            
            // markers parameter is an absolute size (integer), not a multiplier
            // If not specified, default to 1.1x width
            var markerRadius;
            if (params.markers !== undefined) {
                markerRadius = parseInt(params.markers);
            } else {
                markerRadius = Math.round(width * 1.1);
            }
            
            // Create a layer group to hold both the line and point markers
            var layerGroup = L.layerGroup();
            
            // Add the polyline
            var line = L.polyline(msg.coords, {
                color: color,
                weight: width,
                opacity: opacity
            });
            layerGroup.addLayer(line);
            
            // Add circle markers at each point (if markers > 0)
            if (markerRadius > 0) {
                msg.coords.forEach(function(coord) {
                    var marker = L.circleMarker(coord, {
                        radius: markerRadius,
                        color: color,
                        fillColor: color,
                        fillOpacity: 1.0,
                        weight: 2
                    });
                    layerGroup.addLayer(marker);
                });
            }
            
            layer = layerGroup;
            layer.addTo(map);
            
            // Build tooltip text
            var tooltipText = '';
            if (label) {
                tooltipText = label;
            }
            if (tag) {
                tooltipText += (tooltipText ? ' [' : '[') + tag + ']';
            }
            if (tooltipText) {
                line.bindTooltip(tooltipText);
            }
        } else if (msg.type === 'polygon') {
            var opacity = params.opacity ? parseFloat(params.opacity) : 0.3;
            
            layer = L.polygon(msg.coords, {
                color: color,
                fillColor: color,
                fillOpacity: opacity,
                weight: 2
            }).addTo(map);
            
            // Build tooltip text
            var tooltipText = '';
            if (label) {
                tooltipText = label;
            }
            if (tag) {
                tooltipText += (tooltipText ? ' [' : '[') + tag + ']';
            }
            if (tooltipText) {
                layer.bindTooltip(tooltipText);
            }
        } else {
            console.warn('Unknown feature type', msg.type);
            return;
        }

        features[msg.id] = layer;
        
        // Auto-fit bounds to show all features (if autofocus enabled)
        if (autofocus && Object.keys(features).length > 0) {
            var bounds = null;
            Object.values(features).forEach(function(feature) {
                var featureBounds = null;
                if (feature.getBounds) {
                    featureBounds = feature.getBounds();
                } else if (feature.getLatLng) {
                    // Single marker
                    var latlng = feature.getLatLng();
                    featureBounds = L.latLngBounds([latlng, latlng]);
                } else if (feature instanceof L.LayerGroup) {
                    // For LayerGroups (like polylines with markers), calculate bounds from all layers
                    var groupBounds = null;
                    feature.eachLayer(function(subLayer) {
                        if (subLayer.getBounds) {
                            var subBounds = subLayer.getBounds();
                            groupBounds = groupBounds ? groupBounds.extend(subBounds) : subBounds;
                        } else if (subLayer.getLatLng) {
                            var latlng = subLayer.getLatLng();
                            groupBounds = groupBounds ? groupBounds.extend(latlng) : L.latLngBounds([latlng, latlng]);
                        }
                    });
                    featureBounds = groupBounds;
                }
                
                if (featureBounds) {
                    bounds = bounds ? bounds.extend(featureBounds) : featureBounds;
                }
            });
            
            if (bounds) {
                map.fitBounds(bounds, { padding: [20, 20] });
            }
        }
    }

    function removeFeature(id) {
        var layer = features[id];
        if (layer) {
            map.removeLayer(layer);
            delete features[id];
            console.log('Removed feature', id);
        } else {
            console.warn('Feature not found', id);
        }
    }
    
    function removeFeaturesByTag(ids) {
        ids.forEach(function(id) {
            var layer = features[id];
            if (layer) {
                map.removeLayer(layer);
                delete features[id];
            }
        });
        console.log('Removed', ids.length, 'features by tag');
    }

    function clearAllFeatures() {
        Object.keys(features).forEach(function(id) {
            map.removeLayer(features[id]);
        });
        features = {};
        console.log('Cleared all features');
    }
    
    function updateCurrentPosition(coords) {
        // Remove old marker if exists
        if (currentPositionMarker) {
            map.removeLayer(currentPositionMarker);
        }
        
        // Calculate heading (bearing) from previous position
        var rotation = 0;
        if (previousPosition) {
            var lat1 = previousPosition[0] * Math.PI / 180;
            var lat2 = coords[0] * Math.PI / 180;
            var dLon = (coords[1] - previousPosition[1]) * Math.PI / 180;
            
            var y = Math.sin(dLon) * Math.cos(lat2);
            var x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
            rotation = Math.atan2(y, x) * 180 / Math.PI;
        }
        
        // Create chevron icon (pointing upward, will be rotated)
        var chevronIcon = L.divIcon({
            className: 'current-position-icon',
            html: '<div style="transform: rotate(' + rotation + 'deg); width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 20px solid #4285F4; margin-left: -10px; margin-top: -10px;"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
        
        // Add new marker
        currentPositionMarker = L.marker(coords, { icon: chevronIcon }).addTo(map);
        
        // Follow position if enabled
        if (followPosition) {
            map.setView(coords, map.getZoom());
        }
        
        // Store for next heading calculation
        previousPosition = coords;
    }
    </script>
</body>
</html>
